name: CI

on:
  pull_request:
    branches: [main]

# Queue plan runs for the same PR but never cancel in-progress plans
# Plans must complete to show accurate infrastructure diffs
concurrency:
  group: ci-plan-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: false

env:
  OPENTOFU_VERSION: "1.8.0"
  TERRAGRUNT_VERSION: "0.54.0"

jobs:
  # ─────────────────────────────────────────────────────────────────────────────
  # Lint: Format check (fast, no credentials)
  # ─────────────────────────────────────────────────────────────────────────────
  lint:
    name: Lint
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.OPENTOFU_VERSION }}
          tofu_wrapper: false

      - name: Check formatting
        run: |
          if ! tofu fmt -check -recursive infrastructure/; then
            echo "::error::Files need formatting. Run: tofu fmt -recursive infrastructure/"
            exit 1
          fi
          echo "✅ All files formatted correctly"

  # ─────────────────────────────────────────────────────────────────────────────
  # Docs: Documentation check (fast, no credentials)
  # ─────────────────────────────────────────────────────────────────────────────
  docs:
    name: Docs
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install terraform-docs
        run: |
          curl -sSLo terraform-docs.tar.gz https://github.com/terraform-docs/terraform-docs/releases/download/v0.17.0/terraform-docs-v0.17.0-linux-amd64.tar.gz
          tar -xzf terraform-docs.tar.gz
          chmod +x terraform-docs
          sudo mv terraform-docs /usr/local/bin/

      - name: Check documentation
        run: |
          failed=false
          for module in infrastructure/modules/*/; do
            if [ -d "$module" ] && ls "$module"/*.tf 1> /dev/null 2>&1; then
              module_name=$(basename "$module")
              if [ ! -f "$module/README.md" ]; then
                echo "::error::Missing README.md: $module_name"
                failed=true
              elif ! terraform-docs markdown table --output-check "$module"; then
                echo "::error::Docs outdated: $module_name"
                failed=true
              fi
            fi
          done
          if [ "$failed" = true ]; then
            echo "Run: terraform-docs markdown table --output-file README.md --output-mode inject <module>"
            exit 1
          fi
          echo "✅ All module docs up to date"

  # ─────────────────────────────────────────────────────────────────────────────
  # Plan: Terragrunt plan (requires GCP auth)
  # ─────────────────────────────────────────────────────────────────────────────
  plan:
    name: Plan
    runs-on: ubuntu-latest
    needs: [lint, docs]
    permissions:
      contents: read
      id-token: write
      pull-requests: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.OPENTOFU_VERSION }}
          tofu_wrapper: false

      - name: Setup Terragrunt
        run: |
          wget -q https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
          chmod +x terragrunt_linux_amd64
          sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt

      - uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Setup spotctl
        env:
          RACKSPACE_SPOT_TOKEN: ${{ secrets.RACKSPACE_SPOT_API_TOKEN }}
        run: |
          # Install spotctl (used by terraform external data source)
          curl -sL "https://github.com/rackspace-spot/spotctl/releases/download/v0.1.1/spotctl-linux-amd64" -o /tmp/spotctl
          chmod +x /tmp/spotctl

          # Configure spotctl
          mkdir -p ~/.kube
          printf 'org: "matchpoint-ai"\nrefreshToken: "%s"\nregion: "us-central-dfw-1"\n' "$RACKSPACE_SPOT_TOKEN" > ~/.spot_config
          chmod 600 ~/.spot_config

      - name: Check cluster connectivity
        id: cluster_check
        env:
          RACKSPACE_SPOT_TOKEN: ${{ secrets.RACKSPACE_SPOT_API_TOKEN }}
        run: |
          # Try to fetch kubeconfig and test cluster connectivity
          CLOUDSPACE_NAME="matchpoint-runners"
          SPOTCTL="/tmp/spotctl"

          echo "Checking cluster connectivity..."
          if $SPOTCTL cloudspaces get-config --name "$CLOUDSPACE_NAME" 2>/dev/null; then
            KUBECONFIG="$HOME/.kube/$CLOUDSPACE_NAME.yaml"
            if [ -f "$KUBECONFIG" ]; then
              export KUBECONFIG
              # Test API connectivity with 10s timeout
              if timeout 10 kubectl cluster-info &>/dev/null; then
                echo "cluster_reachable=true" >> $GITHUB_OUTPUT
                echo "✅ Cluster API is reachable"
              else
                echo "cluster_reachable=false" >> $GITHUB_OUTPUT
                echo "⚠️ Cluster API timeout - will skip Kubernetes-dependent stages"
              fi
            else
              echo "cluster_reachable=false" >> $GITHUB_OUTPUT
              echo "⚠️ Kubeconfig not available"
            fi
          else
            echo "cluster_reachable=false" >> $GITHUB_OUTPUT
            echo "⚠️ Could not fetch kubeconfig"
          fi

      - name: Terragrunt Plan
        id: plan
        working-directory: infrastructure/live/prod
        env:
          GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          GCS_BUCKET: ${{ secrets.GCS_BUCKET }}
          RACKSPACE_SPOT_TOKEN: ${{ secrets.RACKSPACE_SPOT_API_TOKEN }}
          INFRA_GH_TOKEN: ${{ secrets.INFRA_GH_TOKEN }}
        run: |
          set +e

          # Determine which stages to exclude based on cluster connectivity
          # Exclude stages that require kubernetes_manifest or pending state migration
          EXCLUDE_DIRS="--terragrunt-exclude-dir 3-argocd-apps"
          EXCLUDE_DIRS="$EXCLUDE_DIRS --terragrunt-exclude-dir 3-arc-prereqs"
          EXCLUDE_DIRS="$EXCLUDE_DIRS --terragrunt-exclude-dir 4-argocd-bootstrap"
          if [ "${{ steps.cluster_check.outputs.cluster_reachable }}" != "true" ]; then
            echo "::warning::Cluster unreachable - excluding 2-cluster-base from plan"
            EXCLUDE_DIRS="$EXCLUDE_DIRS --terragrunt-exclude-dir 2-cluster-base"
          fi

          # Run plan with appropriate exclusions
          # 3-argocd-apps: deprecated, replaced by 3-arc-prereqs + 4-argocd-bootstrap
          # 3-arc-prereqs, 4-argocd-bootstrap: require state migration before CI can plan
          # 2-cluster-base: excluded if cluster API is unreachable
          # Using -lock=false because plans are read-only and shouldn't compete for state locks
          # This allows CI to run even when a deploy is in progress
          terragrunt run-all plan -no-color -lock=false $EXCLUDE_DIRS 2>&1 | tee plan.txt
          exitcode=${PIPESTATUS[0]}
          echo "exitcode=$exitcode" >> $GITHUB_OUTPUT
          echo "output<<EOF" >> $GITHUB_OUTPUT
          head -c 60000 plan.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post Plan to PR
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const output = `${{ steps.plan.outputs.output }}`;
            const exitcode = '${{ steps.plan.outputs.exitcode }}';
            const status = exitcode === '0' ? '✅' : '❌';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `#### ${status} Terragrunt Plan\n<details><summary>Show Plan</summary>\n\n\`\`\`\n${output}\n\`\`\`\n</details>`
            });

      - name: Check Plan Result
        if: steps.plan.outputs.exitcode != '0'
        run: exit 1
