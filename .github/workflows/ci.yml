name: CI

on:
  pull_request:
    branches: [main]

env:
  OPENTOFU_VERSION: "1.8.0"
  TERRAGRUNT_VERSION: "0.54.0"

jobs:
  # ─────────────────────────────────────────────────────────────────────────────
  # Lint: Format check (fast, no credentials)
  # ─────────────────────────────────────────────────────────────────────────────
  lint:
    name: Lint
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.OPENTOFU_VERSION }}
          tofu_wrapper: false

      - name: Check formatting
        run: |
          if ! tofu fmt -check -recursive infrastructure/; then
            echo "::error::Files need formatting. Run: tofu fmt -recursive infrastructure/"
            exit 1
          fi
          echo "✅ All files formatted correctly"

  # ─────────────────────────────────────────────────────────────────────────────
  # Docs: Documentation check (fast, no credentials)
  # ─────────────────────────────────────────────────────────────────────────────
  docs:
    name: Docs
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install terraform-docs
        run: |
          curl -sSLo terraform-docs.tar.gz https://github.com/terraform-docs/terraform-docs/releases/download/v0.17.0/terraform-docs-v0.17.0-linux-amd64.tar.gz
          tar -xzf terraform-docs.tar.gz
          chmod +x terraform-docs
          sudo mv terraform-docs /usr/local/bin/

      - name: Check documentation
        run: |
          failed=false
          for module in infrastructure/modules/*/; do
            if [ -d "$module" ] && ls "$module"/*.tf 1> /dev/null 2>&1; then
              module_name=$(basename "$module")
              if [ ! -f "$module/README.md" ]; then
                echo "::error::Missing README.md: $module_name"
                failed=true
              elif ! terraform-docs markdown table --output-check "$module"; then
                echo "::error::Docs outdated: $module_name"
                failed=true
              fi
            fi
          done
          if [ "$failed" = true ]; then
            echo "Run: terraform-docs markdown table --output-file README.md --output-mode inject <module>"
            exit 1
          fi
          echo "✅ All module docs up to date"

  # ─────────────────────────────────────────────────────────────────────────────
  # Plan: Terragrunt plan (requires GCP auth)
  # ─────────────────────────────────────────────────────────────────────────────
  plan:
    name: Plan
    runs-on: ubuntu-latest
    needs: [lint, docs]
    permissions:
      contents: read
      id-token: write
      pull-requests: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.OPENTOFU_VERSION }}
          tofu_wrapper: false

      - name: Setup Terragrunt
        run: |
          wget -q https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
          chmod +x terragrunt_linux_amd64
          sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt

      - uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Setup spotctl and fetch kubeconfig
        env:
          RACKSPACE_SPOT_TOKEN: ${{ secrets.RACKSPACE_SPOT_API_TOKEN }}
        run: |
          # Install spotctl
          curl -sL "https://github.com/rackspace-spot/spotctl/releases/download/v0.1.1/spotctl-linux-amd64" -o /tmp/spotctl
          chmod +x /tmp/spotctl

          # Configure spotctl
          mkdir -p ~/.kube
          printf 'org: "matchpoint-ai"\nrefreshToken: "%s"\nregion: "us-central-dfw-1"\n' "$RACKSPACE_SPOT_TOKEN" > ~/.spot_config
          chmod 600 ~/.spot_config

          # Fetch kubeconfig for the cloudspace
          CLUSTER_NAME="matchpoint-runners"
          if /tmp/spotctl cloudspaces get --name "$CLUSTER_NAME" --output json | grep -q '"status": "Ready"'; then
            /tmp/spotctl cloudspaces get-config --name "$CLUSTER_NAME"
            # Copy to module directory where terraform expects it
            MODULE_DIR="infrastructure/modules/cloudspace"
            if [ -f "$HOME/.kube/$CLUSTER_NAME.yaml" ]; then
              cp "$HOME/.kube/$CLUSTER_NAME.yaml" "$MODULE_DIR/kubeconfig.yaml"
              echo "✅ Kubeconfig fetched for $CLUSTER_NAME"
            fi
          else
            echo "⚠️ Cloudspace not ready, skipping kubeconfig fetch"
          fi

      - name: Terragrunt Plan
        id: plan
        working-directory: infrastructure/live/prod
        env:
          GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          GCS_BUCKET: ${{ secrets.GCS_BUCKET }}
          RACKSPACE_SPOT_TOKEN: ${{ secrets.RACKSPACE_SPOT_API_TOKEN }}
          INFRA_GH_TOKEN: ${{ secrets.INFRA_GH_TOKEN }}
        run: |
          set +e
          # Skip stages that require live cluster API:
          # - 2-cluster-base: requires kubeconfig for helm/kubernetes providers
          # - 3-argocd-apps: kubernetes_manifest requires live cluster API
          # Note: 1-cloudspace is now plannable since we fetch kubeconfig via spotctl
          terragrunt run-all plan -no-color \
            --terragrunt-exclude-dir 2-cluster-base \
            --terragrunt-exclude-dir 3-argocd-apps 2>&1 | tee plan.txt
          exitcode=${PIPESTATUS[0]}
          echo "exitcode=$exitcode" >> $GITHUB_OUTPUT
          echo "output<<EOF" >> $GITHUB_OUTPUT
          head -c 60000 plan.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post Plan to PR
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const output = `${{ steps.plan.outputs.output }}`;
            const exitcode = '${{ steps.plan.outputs.exitcode }}';
            const status = exitcode === '0' ? '✅' : '❌';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `#### ${status} Terragrunt Plan\n<details><summary>Show Plan</summary>\n\n\`\`\`\n${output}\n\`\`\`\n</details>`
            });

      - name: Check Plan Result
        if: steps.plan.outputs.exitcode != '0'
        run: exit 1
